#!/bin/bash
#
# Embed hash replaces `$Hash$` to `$Hash:{sha224sum}$`
# When calculating the hash, `$Hash:...$` should be treated as `$Hash$`.
#
# Example: hash-embed update-all

USAGE=$(cat << '__END__'
Usage: hash-embed <sub-command> [arguments]

Sub-commands:

    calc {files}      Calculate new hash value for files
    extract {files}   Extract current hash value from files
    verify {files}    Verify that the file hash values match
    update {files}    Update hash value in files
    list              List target files which have embeded hash

    calc-all          Calc hash values for files w/ `$Hash$` tag
    extract-all       Extract hash values from files w/ `$Hash$` tag
    update-all        Update hash values in files w/ `$Hash$` tag

    copy              Copy files w/ `$Hash$` tag to current directory
    clean-backup      Remove *.bak files created by copy sub command

    gh-search         Search for repos that need (or don't need) updating
    gh-update {repo}  Update hash embedded files for the repository
    git-commit        Commit changes to files managed by hash-embed
__END__
)

set -eu

SRCNAME=$(realpath "$0")
SRCDIR=$(dirname "$SRCNAME")

calc() {
  sed -E -e 's/\$Hash:[^$]*\$/\$Hash\$/' "$1" | sha224sum | cut -f 1 -d ' '
}

extract() {
  if [ "$1" == "hash-embed" ] ; then
    hash="(skipped)"
  elif [ -f "$1" ] ; then
    hash=$(sed -nEr 's/.*\$Hash:([^$]*)\$.*/\1/p' "$1")
    if [ -z "$hash" ] ; then
      hash="(no hash)"
    fi
  else
    hash="(not a file)"
  fi
  echo "$hash"
}

verify() {
  if [ ! -f "$1" ] ; then
    echo "NOT_FOUND"
    return
  fi
  want=$(extract "$1")
  got=$(calc "$1")
  if [ "$got" == "$want" ] ; then
    echo "OK"
  else
    echo "FAILED"
  fi
}

list() {
  grep --exclude='hash-embed*' --exclude-dir=tmp -lrE '\$Hash(:[^$]*)?\$'
}

update() {
  old=$(extract "$1")
  new=$(calc "$1")
  if [ "$new" != "$old" ] ; then
    echo -e "$f\n    Old: $old\n    New: $new"
    sed -i.bak -E -e "s/\\\$Hash(:[^\\$]*)?\\$/\$Hash:${new}\$/" "$1"
    rm -f "$1.bak"
  fi
}

subcmd_calc() {
  for f in "$@" ; do
    hash=$(calc "$f")
    printf "%-56s  %s\n" "$hash" "$f"
  done
}

subcmd_extract() {
  for f in "$@" ; do
    hash=$(extract "$f")
    printf "%-56s  %s\n" "$hash" "$f"
  done
}

subcmd_verify() {
  for f in "$@" ; do
    printf "%s: %s\n" "$f" $(verify "$f")
  done
}

subcmd_list() {
  list
}

subcmd_update() {
  for f in "$@" ; do
    update "$f"
  done
}

subcmd_calc_all() {
  subcmd_calc $(list)
}

subcmd_extract_all() {
  subcmd_extract $(list)
}

subcmd_update_all() {
  subcmd_update $(list)
}

subcmd_copy() {
  files=$( cd "$SRCDIR" && list )
  for file in $files ; do
    if [ -f "$file" ] ; then
      # Create a backup of local files if they have changed
      if [ $(verify "$file") != "OK" ] ; then
        rm -f "$file.bak"
        mv "$file" "$file.bak"
        cp "${SRCDIR}/${file}" "$file"
        echo "${file}: COPIED_WITH_BACKUP"
        continue
      fi
      if [ $(calc "$SRCDIR/$file") == $(calc "$file") ] ; then
        echo "${file}: NO_CHANGES"
        continue
      fi
    fi
    cp "${SRCDIR}/${file}" "$file"
    echo "${file}: COPIED"
  done
}

subcmd_clean_backup() {
  files=$( cd "$SRCDIR" && list )
  for file in $files ; do
    rm -f "$file.bak"
  done
}

subcmd_gh_search() {
  owner=koron-go
  file=.github/workflows/go.yml
  not=NOT
  verbose=0
  while getopts o:f:nvh OPT ; do
    case $OPT in
      o) owner="$OPTARG" ;;
      f) file="$OPTARG" ;;
      n) not="" ;;
      v) verbose=1 ;;
      h) subcmd_gh_search_help && exit 0 ;;
      *) subcmd_gh_search_help && exit 1 ;;
    esac
  done
  hash=$(extract "$SRCDIR/$file")
  if [ $verbose -ne 0 ] ; then
    echo -e "Owner: ${owner}\nFile: ${file}\nHash: ${hash}"
  fi
  if [ "$hash" == "(not a file)" ] ; then
    echo "no hashes in the file: ${file}"
    exit 1
  fi
  gh search code --owner "$owner" --filename "$file" --match file $not "$hash"
}

subcmd_gh_search_help() {
  cat << '__END__'
Usage: hash-embed gh-search [OPTIONS]

OPTIONS:

    -o {owner}    Owner or group (default: koron-go)
    -f {file}     Pivot file for search (default: .github/workflows/go.yml)
    -n            Search for repos that don't need updating

    -v            Verbose message
    -h            Show this message
__END__
}

subcmd_gh_update() {
  repo=$1 ; shift
  url="git@github.com:${repo}.git"
  dirname=${repo//\//--}
  tmpdir="tmp/$dirname"
  if [ ! -d "$tmpdir" ] ; then
    echo "Cloning $url to $tmpdir"
    git clone --quiet --depth 1 "$url" "$tmpdir"
  fi
  self=$(realpath "$0")
  echo "Updating $tmpdir"
  ( cd "$tmpdir" && subcmd_copy && subcmd_git_commit)
  echo "Pushing $tmpdir to $url"
  ( cd "$tmpdir" && git push --quiet )
  echo "Cleaning $tmpdir"
  rm -rf "$tmpdir"
}

commit_message() {
  # Determine the basename from the repository name
  url=$(cd "$SRCDIR" && git remote get-url origin)
  url=${url#*:}
  basename=${url%.git}
  hash=$(cd "$SRCDIR" && git rev-parse --short HEAD)
  message="Update files from ${basename} ${hash}"
  echo "$message"
}

has_local_changes() {
  files=$( cd "$SRCDIR" && list )
  found=0
  for file in $files ; do
    bak="$file.bak"
    if [ -f "$bak" ] ; then
      echo "Found local changes for: $bak"
      found=1
    fi
  done
  return $found
}

subcmd_git_commit() {
  if ! has_local_changes ; then
    echo "Please review the changes and delete the backup files to continue."
    exit 1
  fi
  files=$( cd "$SRCDIR" && list )
  git add $files
  if git diff-index --quiet HEAD $files ; then
    echo "No changes, so abort commit."
    return 0
  fi
  git commit --quiet -m "$(commit_message)"
  return 0
}

subcmd_help() {
  echo "$USAGE"
}

if [ "$#" -lt 1 ] ; then
  subcmd_help
  exit 1
fi

case $1 in
  calc)
    shift
    subcmd_calc "$@"
    ;;
  extract)
    shift
    subcmd_extract "$@"
    ;;
  verify)
    shift
    subcmd_verify "$@"
    ;;
  update)
    shift
    subcmd_update "$@"
    ;;
  list)
    subcmd_list
    ;;
  calc-all)
    subcmd_calc_all
    ;;
  extract-all)
    subcmd_extract_all
    ;;
  update-all)
    subcmd_update_all
    ;;
  copy)
    subcmd_copy
    ;;
  clean-backup)
    subcmd_clean_backup
    ;;
  gh-search)
    shift
    subcmd_gh_search "$@"
    ;;
  gh-update)
    shift
    subcmd_gh_update "$@"
    ;;
  git-commit)
    subcmd_git_commit
    ;;
  help)
    subcmd_help
    exit 0
    ;;
  *)
    subcmd_help
    exit 1
    ;;
esac
